<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>S8_1_GLM_Poisson</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="S8_1_GLM_Poisson_files/libs/clipboard/clipboard.min.js"></script>
<script src="S8_1_GLM_Poisson_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="S8_1_GLM_Poisson_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="S8_1_GLM_Poisson_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="S8_1_GLM_Poisson_files/libs/quarto-html/popper.min.js"></script>
<script src="S8_1_GLM_Poisson_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="S8_1_GLM_Poisson_files/libs/quarto-html/anchor.min.js"></script>
<link href="S8_1_GLM_Poisson_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="S8_1_GLM_Poisson_files/libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="S8_1_GLM_Poisson_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="S8_1_GLM_Poisson_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="S8_1_GLM_Poisson_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#plan-du-cours" id="toc-plan-du-cours" class="nav-link active" data-scroll-target="#plan-du-cours"><span class="header-section-number">1</span> Plan du cours</a></li>
  <li><a href="#introduction-données-de-comptage-données-longtiduinales-données-en-cluster" id="toc-introduction-données-de-comptage-données-longtiduinales-données-en-cluster" class="nav-link" data-scroll-target="#introduction-données-de-comptage-données-longtiduinales-données-en-cluster"><span class="header-section-number">2</span> Introduction : données de comptage, données longtiduinales, données en cluster</a>
  <ul>
  <li><a href="#données-de-comptage" id="toc-données-de-comptage" class="nav-link" data-scroll-target="#données-de-comptage"><span class="header-section-number">2.1</span> Données de comptage</a>
  <ul>
  <li><a href="#exemple-de-données-de-comptage" id="toc-exemple-de-données-de-comptage" class="nav-link" data-scroll-target="#exemple-de-données-de-comptage"><span class="header-section-number">2.1.1</span> Exemple de données de comptage</a></li>
  <li><a href="#approximation-binomiale-poisson" id="toc-approximation-binomiale-poisson" class="nav-link" data-scroll-target="#approximation-binomiale-poisson"><span class="header-section-number">2.1.2</span> Approximation binomiale / Poisson</a></li>
  <li><a href="#surdispersion" id="toc-surdispersion" class="nav-link" data-scroll-target="#surdispersion"><span class="header-section-number">2.1.3</span> Surdispersion</a></li>
  <li><a href="#excès-de-0" id="toc-excès-de-0" class="nav-link" data-scroll-target="#excès-de-0"><span class="header-section-number">2.1.4</span> Excès de 0</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#modèle-de-poisson" id="toc-modèle-de-poisson" class="nav-link" data-scroll-target="#modèle-de-poisson"><span class="header-section-number">3</span> Modèle de poisson</a>
  <ul>
  <li><a href="#modèle" id="toc-modèle" class="nav-link" data-scroll-target="#modèle"><span class="header-section-number">3.1</span> Modèle</a></li>
  <li><a href="#interprétation-des-coefficients" id="toc-interprétation-des-coefficients" class="nav-link" data-scroll-target="#interprétation-des-coefficients"><span class="header-section-number">3.2</span> Interprétation des coefficients</a></li>
  <li><a href="#données-longitudinales" id="toc-données-longitudinales" class="nav-link" data-scroll-target="#données-longitudinales"><span class="header-section-number">3.3</span> Données longitudinales</a></li>
  </ul></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="S8_1_GLM_Poisson.docx"><i class="bi bi-file-word"></i>MS Word</a></li><li><a href="../S8_1_GLM_Poisson.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">S8_1_GLM_Poisson</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="plan-du-cours" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Plan du cours</h1>
<ol type="1">
<li><p>Introduction : données de comptage, données longtiduinales, données en cluster</p></li>
<li><p>Modèles de Poisson pour les données de comptage</p>
<ul>
<li><p>Loi de Poisson</p></li>
<li><p>Interprétation des coefficients</p></li>
<li><p>Cas des données sur-dispersées (variance &gt; moyenne)</p></li>
</ul></li>
</ol>
</section>
<section id="introduction-données-de-comptage-données-longtiduinales-données-en-cluster" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Introduction : données de comptage, données longtiduinales, données en cluster</h1>
<section id="données-de-comptage" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="données-de-comptage"><span class="header-section-number">2.1</span> Données de comptage</h2>
<p>Les données de comptage sont des données qui représentent le nombre d’occurrences d’un événement dans un intervalle de temps ou d’espace donné.</p>
<ul>
<li><p><strong>Variable aléatoire discrète</strong></p>
<ul>
<li><p>Valeur dans les entiers naturels positifs (0, 1, 2, …)</p></li>
<li><p>Exemples : nombre de visites à l’hôpital, nombre d’accidents de la route, nombre de naissances, etc.</p></li>
</ul></li>
<li><p><strong>Ordre de grandeur des comptages</strong></p>
<ul>
<li><p>Souvent, les comptages sont de taille modérée (par exemple, de 0 à quelques dizaines).</p></li>
<li><p>Cependant, ils peuvent aussi être très élevés dans certains contextes (par exemple, le nombre de visiteurs sur un site web).</p></li>
</ul></li>
<li><p><strong>Caractéristiques des données de comptage</strong></p>
<ul>
<li><p>Beaucoup de zéros (événements rares)</p></li>
<li><p><strong>Pas d’unité !</strong> : les comptages sont des nombres absolus</p></li>
<li><p>Distribution asymétrique : la distribution est souvent biaisée à droite (peu de grandes valeurs)</p></li>
<li><p>Non normale : les données de comptage ne suivent pas une distribution normale</p></li>
<li><p>Relation moyenne-variance : dans une distribution de Poisson, <strong>la variance est souvent égale voire supérieure à la moyenne (sur-dispersion)</strong></p></li>
<li><p>On peut comparer les deux car pas d’unité</p></li>
</ul></li>
<li><p><strong>Lien avec la distribution de Poisson</strong></p>
<ul>
<li><p>La distribution de Poisson est souvent utilisée pour modéliser les données de comptage.</p></li>
<li><p>Elle est caractérisée par un paramètre <span class="math inline">\(\lambda\)</span> qui représente à la fois la moyenne et la variance des comptages.</p></li>
<li><p><span class="math inline">\(\lambda\)</span> correspond au taux moyen d’occurrence de l’événement par unité de temps ou d’espace.</p></li>
</ul></li>
<li><p><strong>Notion d’exposition</strong></p>
<ul>
<li><p>Dans certains cas, les données de comptage sont associées à une notion d’exposition, c’est-à-dire la durée ou la surface pendant laquelle les événements peuvent se produire.</p></li>
<li><p>Par exemple, le nombre d’accidents de la route peut être rapporté au nombre de kilomètres parcourus.</p></li>
<li><p>L’exposition est souvent utilisée comme un offset dans les modèles de régression pour ajuster les comptages en fonction de la durée ou de la surface d’observation.</p></li>
</ul></li>
</ul>
<p><strong>Loi de Poisson</strong></p>
<ul>
<li><p>Paramètre <span class="math inline">\(\lambda &gt; 0\)</span> (ne peut pas être négatif)</p></li>
<li><p>Espérance : <span class="math inline">\(\mathbb{E}(X) = \lambda\)</span></p></li>
<li><p>Variance : <span class="math inline">\(\mathrm{Var}(X) = \lambda\)</span></p></li>
</ul>
<p>= distribution de probabilité discrète</p>
<ul>
<li><p>décrivant le nombre d’événements se produisant dans un intervalle de temps ou d’espace fixe,</p></li>
<li><p>lorsque ces événements se produisent avec une moyenne constante et indépendamment du temps écoulé depuis le dernier événement.</p></li>
</ul>
<p><span class="math inline">\(P(X = k) = \frac{\lambda^k}{k!} \times e^{-\lambda}\)</span>, pour <span class="math inline">\(k = 0, 1, 2, ...\)</span></p>
<section id="exemple-de-données-de-comptage" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1" class="anchored" data-anchor-id="exemple-de-données-de-comptage"><span class="header-section-number">2.1.1</span> Exemple de données de comptage</h3>
<p>10 000 tirages d’une variable aléatoire</p>
<ul>
<li><p>avec loi de Poisson de paramètre <span class="math inline">\(\lambda = 1\)</span> (donc moyenne et variance égales à 1)</p></li>
<li><p>avec loi de Poisson de paramètre <span class="math inline">\(\lambda = 5\)</span> (donc moyenne et variance égales à 5)</p></li>
<li><p>avec loi de Poisson de paramètre <span class="math inline">\(\lambda = 20\)</span> (donc moyenne et variance égales à 20)</p></li>
</ul>
<p><img src="images/paste-50.png" class="img-fluid"></p>
<p>Plus le paramètre <span class="math inline">\(\lambda\)</span> est grand, plus la distribution ressemble à une distribution normale.</p>
<p>Pour <span class="math inline">\(\lambda = 1\)</span> ou <span class="math inline">\(5\)</span>, la distribution est asymétrique et concentrée sur les petites valeurs.</p>
<p>Donc cette loi a moins d’intérêt pour des comptages élevés.</p>
</section>
<section id="approximation-binomiale-poisson" class="level3" data-number="2.1.2">
<h3 data-number="2.1.2" class="anchored" data-anchor-id="approximation-binomiale-poisson"><span class="header-section-number">2.1.2</span> Approximation binomiale / Poisson</h3>
<ul>
<li><p>Loi binomiale <span class="math inline">\(\mathfrak{B}(n, p)\)</span> = nombre de succès dans n essais indépendants, avec probabilité p de succès à chaque essai.</p>
<ul>
<li>Exemple : nombre d’appels au SAMU dans une journée parmi 10 000 habitants, avec une probabilité p d’appel faible.</li>
</ul></li>
</ul>
<p>Démarche de modélisation :</p>
<ul>
<li><p>La ville contient un nombre <span class="math inline">\(n\)</span> d’habitants (très grand)</p></li>
<li><p>Chaque habitant a une probabilité <span class="math inline">\(p\)</span> (très petite) d’appeler le SAMU dans la journée</p></li>
<li><p>Les appels surviennent de manière indépendante entre les habitants</p></li>
<li><p>Le nombre total d’appels <span class="math inline">\(X\)</span> suit une loi binomiale <span class="math inline">\(B(n, p)\)</span>, d’espérance <span class="math inline">\(\lambda = n \times p\)</span></p></li>
</ul>
<p><img src="images/paste-49.png" class="img-fluid"></p>
<p>En augmentant <span class="math inline">\(n\)</span> et en diminuant <span class="math inline">\(p\)</span> de manière à ce que le produit <span class="math inline">\(n \times p\)</span> reste constant, la loi binomiale <span class="math inline">\(\mathfrak{B}(n, p)\)</span> se rapproche de la loi de Poisson (de paramètre <span class="math inline">\(\lambda = n \times p\)</span>).</p>
</section>
<section id="surdispersion" class="level3" data-number="2.1.3">
<h3 data-number="2.1.3" class="anchored" data-anchor-id="surdispersion"><span class="header-section-number">2.1.3</span> Surdispersion</h3>
<p><img src="images/paste-51.png" class="img-fluid" width="377"></p>
<p>Exemple : données de transcriptomique <a href="https://bowtie-bio.sourceforge.net/recount/">Bowtie</a></p>
<ul>
<li><p>Chaque gène a un niveau d’expression (entier positif) sur chaque échantillon</p></li>
<li><p>On représente, pour chaque gène, la variance en fonction de la moyenne</p></li>
<li><p>Sous l’hypothèse d’une loi de Poisson, les points devraient tomber proche de la diagonale <span class="math inline">\(y = x\)</span></p></li>
</ul>
<p>Or : ce n’est pas la cas !</p>
<p>Il faut donc une loi plus générale (ex. loi binomiale négative) pour modéliser ces données.</p>
</section>
<section id="excès-de-0" class="level3" data-number="2.1.4">
<h3 data-number="2.1.4" class="anchored" data-anchor-id="excès-de-0"><span class="header-section-number">2.1.4</span> Excès de 0</h3>
<p><img src="images/paste-52.png" class="img-fluid" width="328"></p>
<p>Exemple : nombre d’épisode de migraine durant la dernière année</p>
<ul>
<li><p>Les nons malades n’ont pas d’épisode (0) = zéros “structurels” ;</p></li>
<li><p>Les malades peuvent aussi ne pas avoir d’épisode = zéros “aléatoires”, mais aussi 1, 2, …</p></li>
<li><p>Il en résulte un excès de 0 par rapport à une distribution “standard”</p></li>
</ul>
<p><strong>Solution : un modèle de mélange (on modélise à part les “faux” 0 : “zero-inflated model”)</strong></p>
<ul>
<li><p>1ère partie du modèle estime la probabilité d’être toujours à 0 (par exemple “non malade”) ;</p></li>
<li><p>2nde partie du modèle estime le comptage conditionnel (0, 1, 2, …) chez les individus susceptibles d’avoir des événements (par exemple les malades), souvent avec une Poisson ou une binomiale négative.</p></li>
<li><p>Ce type de modèle permet de mieux tenir compte de la structure des données et d’obtenir des estimations plus réalistes des effets des covariables.</p></li>
</ul>
</section>
</section>
</section>
<section id="modèle-de-poisson" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Modèle de poisson</h1>
<section id="modèle" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="modèle"><span class="header-section-number">3.1</span> Modèle</h2>
<p>On observe</p>
<ul>
<li><p>une réponse Y de type comptage (0, 1, 2, …)</p></li>
<li><p>des covariables explicatives X1, X2, …, Xp, dont on souhaite examiner l’association avec la moyenne de Y.</p></li>
</ul>
<p>On modélise le paramètre <span class="math inline">\(\lambda\)</span> de la loi de Poisson (moyenne et variance de Y) via une fonction de lien exponentielle :</p>
<p><span class="math inline">\(Y \sim Poisson(\lambda) \\\)</span></p>
<p><span class="math inline">\(\lambda = \mathbb{E}(Y|X) = exp(\beta_0 + \beta_1 X_1 + \beta_2 X_2 + ... + \beta_p X_p)\)</span></p>
<p>Donc <span class="math inline">\(\lambda\)</span> est l’exponentielle d’un prédicteur linéaire = fonction log</p>
<p>Le lien assure que <span class="math inline">\(\lambda\)</span> est toujours positif.</p>
<p>C’est différent d’une régression logistique où la moyenne est un “expit” du prédicteur linéaire (donc fonction logit inverse)</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Modèle linéaire</strong> : suppose que chaque variable explicative a un effet additif sur la moyenne de la variable réponse, avec une relation linéaire directe.</p>
<ul>
<li><p>Linéaire = proportionnel et additif : chaque variable explicative influence la moyenne de la variable réponse de manière proportionnelle à son coefficient.</p></li>
<li><p>Additif car les effets des différentes variables explicatives s’additionnent pour déterminer la moyenne de la variable réponse.</p></li>
</ul>
</div>
</div>
<div class="callout::note">
<p>Liens en régressions = fonction de lien = façon de transformer la variable qu’on veut expliquer en quelque chose qu’on peut modéliser linéairement.</p>
<p>La fonction de lien doit être adaptée à la variable</p>
<p>Exprimer une probabilité p (entre 0 et 1) : on la transforme entre -infini et +infini avec la fonction logit ou probit</p>
<ul>
<li><p>logit : fonctionne en faisant le logarithme du rapport entre la probabilité d’un événement et la probabilité de son complément (1 - p)</p></li>
<li><p>probit : utilise la fonction normale cumulative inverse pour transformer la probabilité en une valeur sur l’axe des réels.</p>
<ul>
<li><p>on prend une probabilité p</p></li>
<li><p>on trouve la valeur x telle que la probabilité d’obtenir une valeur ≤ à x dans une distribution normale standard soit égale à p.</p></li>
<li><p>Cela permet de modéliser des données binaires en utilisant une approche basée sur la distribution normale.</p></li>
</ul></li>
<li><p>Exprimer une moyenne μ positive (comptage) : on la transforme entre 0 et +infini avec la fonction log</p></li>
</ul>
</div>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Important
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Régression linéaire</strong> : moyenne est égale au prédicteur linéaire <span class="math display">\[
\mathbb{E}(Y|X) = \beta_0 + \beta_1 X_1 + \beta_2 X_2 + ... + \beta_p X_p
\]</span></p>
<p><strong>Régression logistique</strong> : moyenne est une fonction “expit” du prédicteur linéaire <span class="math display">\[
\mathbb{E}(Y|X) = \frac{exp(\beta_0 + \beta_1 X_1 + \beta_2 X_2 + ... + \beta_p X_p)}{1 + exp(\beta_0 + \beta_1 X_1 + \beta_2 X_2 + ... + \beta_p X_p)}
\]</span></p>
<p><strong>Régression de Poisson</strong> : moyenne est une fonction exponentielle du prédicteur linéaire <span class="math display">\[
\mathbb{E}(Y|X) = exp(\beta_0 + \beta_1 X_1 + \beta_2 X_2 + ... + \beta_p X_p)
\]</span></p>
</div>
</div>
<p><a href="https://thomashusson29.github.io/M2biostatistiques/Bonus_tableau_comparatif_liens_GLM.html">Bonus : tableau comparatif liens GLM</a></p>
</section>
<section id="interprétation-des-coefficients" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="interprétation-des-coefficients"><span class="header-section-number">3.2</span> Interprétation des coefficients</h2>
<ol type="1">
<li>Si la variable X est binaire</li>
</ol>
<p><span class="math inline">\(\lambda_0 = \mathbb{E}(Y\|X=0) = exp(\beta_0)\)</span></p>
<p><span class="math inline">\(\lambda_1 = \mathbb{E}(Y\|X=1) = exp(\beta_0 + \beta_1) = exp(\beta_0) \times exp(\beta_1)\)</span></p>
<p>Donc le ratio des moyennes est</p>
<p><span class="math inline">\(\frac{\lambda_1}{\lambda_0} = \frac{\mathbb{E}(Y\|X=1)}{\mathbb{E}(Y\|X=0)} = \frac{exp(\beta_0 + \beta_1)}{exp(\beta_0)} = exp(\beta_1)\)</span></p>
<p>Le coefficient s’inteprète comme un <strong>log d’un risque relatif</strong>, c’est à dire le logarithme du ratio des moyennes entre les deux groupes.</p>
<ol start="2" type="1">
<li><p>Si la variable X est catégorielle</p>
<ul>
<li><p>On choisit une catégorie de référence (par exemple la première catégorie)</p></li>
<li><p>Comme das les autres modèles linéaires ou GLM</p></li>
<li><p>Chaque coefficient <span class="math inline">\(\beta_k\)</span> correspond au log du ratio des moyennes entre la catégorie k et la catégorie de référence.</p></li>
</ul></li>
<li><p>Si la variable X est continue</p>
<ul>
<li><span class="math inline">\(\exp(\beta_1)\)</span> correspond au RR associé à une augmentation de 1 unité de X.</li>
</ul></li>
</ol>
<p>Dans un modèle multivariable, l’hypothèse est un effet <strong>additif</strong> des variables explicatives sur le <span class="math inline">\(\log(\lambda)\)</span>, donc un effet <strong>multiplicatif</strong> sur <span class="math inline">\(\lambda\)</span>.</p>
</section>
<section id="données-longitudinales" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="données-longitudinales"><span class="header-section-number">3.3</span> Données longitudinales</h2>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>
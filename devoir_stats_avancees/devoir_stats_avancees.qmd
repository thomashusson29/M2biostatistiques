---
title: "Devoir Statistiques Avancées"
author: "Thomas Husson, Groupe 52"
prefer-html: true
format:
    html:
        toc: true
        toc-depth: 5
        toc-title: "Table of contents"
        toc-location: left
        toc-sticky: true
        number-sections: true
        theme: default

    docx:
        toc: true
        toc-depth: 5

    pdf:
        toc: true
        toc-depth: 5
        toc-title: "Table des matières"
        pdf-engine: xelatex
        number-sections: true
        header-includes: |
            % Force la police Computer Modern pour le titre principal
            \makeatletter
            \renewcommand{\maketitle}{
            \begin{center}
                {\Large\bfseries\rmfamily \@title \par}
                \vskip 1.5em
                {\large\rmfamily \@author \par}
                \vskip 1em
            \end{center}
            }
            \makeatother
            % Tous les titres en police par défaut LaTeX
            \usepackage{sectsty}
            \allsectionsfont{\rmfamily}

            \usepackage{etoolbox}
            \renewcommand{\contentsname}{}
            \AtBeginDocument{
                \addtocontents{toc}{\protect\smallskip}
                \let\oldtableofcontents\tableofcontents
                \renewcommand{\tableofcontents}{
                \begingroup
                    \footnotesize
                    \setlength{\parskip}{2pt}
                    \oldtableofcontents
                \endgroup
                }
            }
            \setcounter{tocdepth}{5}
            \makeatletter
            \renewcommand{\@tocrmarg}{0pt}
            \makeatother

            \usepackage{fvextra}
            \usepackage[section]{placeins}

            % Gestion des chunks de code
            \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}

            \usepackage{needspace}
            \usepackage{float}
            \floatplacement{figure}{H}
            \floatplacement{table}{H}

            \newcommand{\sectionbreak}{\needspace{5\baselineskip}}
            \setlength{\parindent}{0pt}
            \setlength{\parskip}{4pt}

            \usepackage[most]{tcolorbox}
            \usepackage{color}
            \definecolor{lightgray}{gray}{0.95}
            \newtcolorbox{graybox}{colback=gray!10!white,colframe=black,boxrule=0.6pt,arc=1mm,left=6pt,right=6pt,top=4pt,bottom=4pt}
            \newtcolorbox{codebox}{breakable,colback=blue!5!white,colframe=blue!50!black,boxrule=0.5pt,arc=1mm,left=4pt,right=4pt,top=3pt,bottom=3pt}
            \DefineVerbatimEnvironment{CodeBoxContent}{Verbatim}{fontsize=\small,breaklines,breakanywhere}

            \renewcommand{\thesection}{\arabic{section}}
            \renewcommand{\thesubsection}{\thesection.\Alph{subsection}}
            \renewcommand{\thesubsubsection}{\thesubsection.\arabic{subsubsection}}

geometry: margin=2.5cm
---

```{r}
#| label: setup
#| include: false
#| echo: false
library(forecast)
library(plotrix)
library(randomForest)
library(tidyr)
library(epiR)
library(viridisLite)
library(ggplot2)
library(binom)
library(survminer)
library(pROC)
library(treemap)
library(psy)
library(MASS)
library(rpart)
library(rpart.plot)
library(plotly)
library(lmerTest)
library(psych)
library(lme4)
library(prettyR)
library(kableExtra)
library(gtsummary)
library(dplyr)
library(lattice)
library(survey)
library(corrplot)
library(mice)
library(paletteer)
library(nord)
library(wesanderson)
library(qgraph)
library(nlme)
library(pwr)
library(ape)
library(survival)
library(gmodels)
library(httpgd)
library(e1071)
library(psy)
library(reshape2)
knitr::opts_chunk$set(echo = TRUE)
```

\newpage

# Énoncé et présentation des échelles

## Énoncé du devoir

Consigne :

-   Étude d'épidémiologie clinique avec mesures répétées

-   Données :

    -   146 patients déprimés

    -   Évaluations à J0, J4, J7, J14, J21, J28, J42, J56

    -   Autoévaluation (SCL90) et hétéroévaluation (échelle de dépression de Hamilton)

-   Questions :

    1.  Validation de l’échelle de dépression de Hamilton aux temps J0 et J56

    2.  Comparaison de la réponse au traitement entre deux groupes de patients (groupe=0 et groupe=1) en utilisant le score brut de Hamilton avec une approche LOCF puis un modèle mixte

    3.  Réponse à la question 2 en utilisant un critère binaire censuré « réponse au traitement » défini par une chute de 50% à l’échelle de Hamilton par rapport à J0

-   Fichiers :

    -   Fichier groupe (`outil groupe.xlsx`) (2 sous-groupes de patients)

    -   Fichier autoévaluation (`outil autoeval.xlsx`) (SCL 90)

    -   Fichier hdrs (`outil hdrs.xlsx`) (échelle de Hamilton)

## Échelles


|          | Échelle de Hamilton (HDRS) | Échelle SCL90 |
|----------|----------------------------|---------------|
| Objectif | Mesure l'intensité de la symptomatologie dépressive | "Inconfort psychopathologique" selon plusieurs dimensions. |
| Type     | Hétéro-évaluation | Autoévaluation |
| Méthode  | 17 items codés de 2 à 4<br><br>- Score ≤ 7 : pas de dépression clinique<br>- Score 8–15 : dépression mineure<br>- Score > 15 : dépression majeure | 10 dimensions : somatisation, symptômes obsessionnels, sensibilité interpersonnelle, dépression, anxiété, hostilité, phobies, traits paranoïaques, traits psychotiques et symptômes divers. |

: {tbl-colwidths="[10,45,45]"}

\newpage
# Gestion des données

## Présentation des fichiers de données

Les 3 fichiers sont en format "large" : chaque ligne correspond à une visite d'un patient et une colonne par item de l'échelle (sauf l'item 16 = PERTE DE POIDS qui est codé en deux variables HAMD16A et HAMD16B dans l'échelle de Hamilton, selon que la perte de poids est déclarée par le patient ou appréciée par le médecin)

On créera donc une colonne `hdrs$HAMD16` qui prendra la valeur de `hdrs$HAMD16A` si elle est remplie, sinon la valeur de `hdrs$HAMD16B`.

### Fichier Hamilton

-   1053 observations, 20 variables pour 146 patients

-   On ajoute une colonne `score` qui contient le score total de l'échelle de Hamilton (somme des items)

-   Les données d'une ligne (J7 du 128ème patient) sont manquantes $\rightarrow$ on supprime cette ligne.

### Fichier scl90

-   1034 observations, 92 variables, 146 patients. 

-   On crée 10 nouvelles variables représentant les scores moyen des 10 dimensions de l'échelle SCL90.

-   Données aberrantes parfois, qui sont recodées en données manquantes et représentent ainsi 0.6% des données totales.


### Fichier groupe

-   Répartit les 146 patients en 2 groupes (1 et 0)

-   Pas de NA

## Import des données et data management

Les données sont importées à partir de fichiers Excel.

```{r}
#| label: import données
#| echo: false
#| results: hide
#| message: false
#| warning: false
library(readxl)
scl90 <- read_excel("/Users/thomashusson/Documents/Projets/M2biostatistiques/devoir_stats_avancees/outils autoeval.xls")
groupe <- read_excel("/Users/thomashusson/Documents/Projets/M2biostatistiques/devoir_stats_avancees/outils groupe.xls")
hdrs <- read_excel("/Users/thomashusson/Documents/Projets/M2biostatistiques/devoir_stats_avancees/outils hdrs.xls")
```

### SCL90

Le jeu de données `scl90` est traité de la manière suivante :

-   Visites ordonnées chronologiquement

-   Identification des doublons

-   Visualisation et gestion des données aberrantes

-   Imputation des données manquantes par le mode pour chaque question

-   Création des scores moyens par dimension (10 dimensions)

-   Nouveau dataframe `scl90_dim` avec uniquement les 10 dimensions

```{r}
#| label: gestion scl90
#| echo: false #affiche le code
#| eval: true #execute le code
#| results: hide # CACHE le résultat texte
#| message: false # cache les messages de chargement
#| warning: false #  Cache les avertissements
describe(scl90)
summary(scl90)

# ordonne chronologiquement les visites pour chaque patient
scl90$VISIT <- factor(scl90$VISIT,
                        levels = c("J0", "J4", "J7", "J14", "J21", "J28", "J42", "J56"),
                        ordered = TRUE)

# ordonner les visites en fonction du numéro de patient
scl90 <- scl90[order(scl90$NUMERO, scl90$VISIT), ] 

# identification des doublons 
scl90$NUMERO[duplicated(scl90)]

# nombre de patients uniques
length(unique(scl90$NUMERO))

# visualisation des données aberrantes
apply(scl90, 2, table, useNA = "always")
scl90[, 3:92][scl90[, 3:92] > 4] <- NA
apply(scl90, 2, table, useNA = "always")

# données manquantes
sum(is.na(scl90))
# proportion : 
sum(is.na(scl90)) / (nrow(scl90) * ncol(scl90))*100

#imputation par le mode pour chaque question 
scl_questions <- c(names(select(scl90,starts_with("Q"))))
for (question in scl_questions) {
    original <- scl90[[question]]
    factorized <- as.factor(original)
    mode_value <- as.integer(names(which.max(table(factorized))))
    imputed <- original
    imputed[is.na(imputed)] <- mode_value
    scl90[[question]] <- imputed
}
# vérifier qu'il n'y a plus de NA
sum(is.na(scl90))

# création des scores moyens par dimension
scl90$somatisation <- apply(scl90[,c(3,6,14,29,44,50,51,54,55,58,60,42)],1,mean,na.rm=TRUE)
scl90$symptomes_obsession <- apply(scl90[,c(11,12,30,40,5,47,48,53,57,67)],1,mean,na.rm=TRUE)
scl90$vulnerabilite <- apply(scl90[,c(8,23,36,38,39,43,63,71,75)],1,mean,na.rm=TRUE)
scl90$depression <- apply(scl90[,c(7,16,17,22,24,28,31,32,33,34,56,73,81)],1,mean,na.rm=TRUE)
scl90$anxiete <- apply(scl90[,c(4,19,25,35,41,59,74,80,82,88)],1,mean,na.rm=TRUE)
scl90$hostilite <- apply(scl90[,c(13,26,65,69,76,83)],1,mean,na.rm=TRUE)
scl90$phobies <- apply(scl90[,c(15,27,49,72,77,84,52)],1,mean,na.rm=TRUE)
scl90$paranoia <- apply(scl90[,c(10,20,45,70,78,85)],1,mean,na.rm=TRUE)
scl90$psychotique <- apply(scl90[,c(9,18,37,64,79,86,87,89,92,90)],1,mean,na.rm=TRUE)
scl90$sympt_divers <- apply(scl90[,c(21,46,61,62,66,68,91)],1,mean,na.rm=TRUE)

# création d'un nouveau dataframe avec uniquement les 10 dimensions
dimensions <- c("somatisation", "symptomes_obsession", "vulnerabilite", "depression", "anxiete", "hostilite", "phobies", "paranoia", "psychotique", "sympt_divers")
scl90_dim <- scl90[, c("NUMERO", "VISIT", dimensions)]
```

###  HDRS

Le jeu de données `hdrs` est traité de la manière suivante :

-   Visites ordonnées chronologiquement

-   Identification des doublons

-   Fusion des variables HAMD16A et HAMD16B en une seule variable HAMD16

-   Création du score total HDRS (ajouté dans la colonne `hdrs$score`)

```{r}
#| label: gestion hdrs
#| echo: false #affiche le code
#| eval: true #execute le code
#| results: hide # CACHE le résultat texte
#| message: false # cache les messages de chargement
#| warning: false #  Cache les avertissements
hdrs$VISIT <- factor(hdrs$VISIT,
                        levels = c("J0", "J4", "J7", "J14", "J21", "J28", "J42", "J56"),
                        ordered = TRUE)

# ordonner les visites en fonction du numéro de patient
hdrs <- hdrs[order(hdrs$NUMERO, hdrs$VISIT), ] 

# identification des doublons 
hdrs$NUMERO[duplicated(hdrs)]

# nombre de patients uniques
length(unique(hdrs$NUMERO))

# fusion des variables HAMD16A et HAMD16B en une seule variable HAMD16
hdrs$HAMD16 <- ifelse(!is.na(hdrs$HAMD16A), hdrs$HAMD16A, hdrs$HAMD16B)
table(hdrs$HAMD16, useNA = "ifany")

# calcul du score total HDRS
items <- c("HAMD1","HAMD2","HAMD3","HAMD4","HAMD5","HAMD6",
            "HAMD7","HAMD8","HAMD9","HAMD10","HAMD11","HAMD12",
            "HAMD13","HAMD14","HAMD15", "HAMD16", "HAMD17")

#renommer la colonne hdrs$HAMD1 en hdrs$humeur_depressive
colnames(hdrs)[colnames(hdrs) == "HAMD1"] <- "1_humeur_depressive"
colnames(hdrs)[colnames(hdrs) == "HAMD2"] <- "2_sentim_culpabilite"
colnames(hdrs)[colnames(hdrs) == "HAMD3"] <- "3_suicide"
colnames(hdrs)[colnames(hdrs) == "HAMD4"] <- "4_insomnie_debut"
colnames(hdrs)[colnames(hdrs) == "HAMD5"] <- "5_insomnie_milieu"
colnames(hdrs)[colnames(hdrs) == "HAMD6"] <- "6_insomnie_matin"
colnames(hdrs)[colnames(hdrs) == "HAMD7"] <- "7_travail_activite"
colnames(hdrs)[colnames(hdrs) == "HAMD8"] <- "8_ralentissement"
colnames(hdrs)[colnames(hdrs) == "HAMD9"] <- "9_agitation"
colnames(hdrs)[colnames(hdrs) == "HAMD10"] <- "10_anxiete_psychique"
colnames(hdrs)[colnames(hdrs) == "HAMD11"] <- "11_anxiete_somatique"
colnames(hdrs)[colnames(hdrs) == "HAMD12"] <- "12_symptomes_gastro"
colnames(hdrs)[colnames(hdrs) == "HAMD13"] <- "13_symptomes_generaux"
colnames(hdrs)[colnames(hdrs) == "HAMD14"] <- "14_symptomes_genitaux"
colnames(hdrs)[colnames(hdrs) == "HAMD15"] <- "15_hypochondrie"
colnames(hdrs)[colnames(hdrs) == "HAMD16"] <- "16_perte_poids"
colnames(hdrs)[colnames(hdrs) == "HAMD17"] <- "17_prise_conscience"

# calcul du score total HDRS
hdrs_items <- c("1_humeur_depressive","2_sentim_culpabilite","3_suicide","4_insomnie_debut","5_insomnie_milieu","6_insomnie_matin","7_travail_activite","8_ralentissement","9_agitation","10_anxiete_psychique","11_anxiete_somatique","12_symptomes_gastro","13_symptomes_generaux","14_symptomes_genitaux","15_hypochondrie","16_perte_poids","17_prise_conscience")

hdrs$score <- rowSums(hdrs[, hdrs_items], na.rm = TRUE)

# supprimer la ligne 741 de hdrs
hdrs <- hdrs[-741, ]

# supprimer HAMD16A et HAMD16B si présentes
hdrs <- hdrs[, setdiff(names(hdrs), c("HAMD16A", "HAMD16B"))]
```

### Groupes 

```{r}
#| label: gestion groupes
#| echo: false #affiche le code
#| eval: true #execute le code
#| results: hide # CACHE le résultat texte
#| message: false # cache les messages de chargement
#| warning: false #  Cache les avertissements
summary(groupe)
describe(groupe)
groupe$NUMERO[duplicated(groupe)]
length(unique(groupe$NUMERO))

# ordonner en fonction du numéro de patient
groupe <- groupe[order(groupe$NUMERO), ] # Questions 1 et 2
```

### Fusion des 3 fichiers

```{r}
#| label: fusion
#| echo: false #affiche le code
#| eval: true #execute le code
#| results: hide # CACHE le résultat texte
#| message: false # cache les messages de chargement
#| warning: false #  Cache les avertissements
# fusion des 3 dataframes
hdrs_groupe <- merge(hdrs, groupe, by = "NUMERO", all.x = TRUE)
scl90_groupe <- merge(scl90, groupe, by = "NUMERO", all.x = TRUE)
df_total_wide <- merge(hdrs_groupe, scl90, by = c("NUMERO", "VISIT"), all.x = TRUE)
```

Convertir `hdrs_groupe`, `scl90_groupe` et `df_total_wide` de format "large" à format "long"

```{r}
#| label: reshape
#| echo: false #affiche le code
#| eval: true #execute le code
#| results: hide # CACHE le résultat texte
#| message: false # cache les messages de chargement
#| warning: false #  Cache les avertissements
library(reshape2)

## HDRS -> long
hdrs_long <- melt(
    hdrs_groupe,
    id.vars = c("NUMERO", "VISIT", "GROUPE"),
    variable.name = "item",
    value.name = "value"
)

## SCL90 -> long
scl90_long <- melt(
    scl90_groupe,
    id.vars = c("NUMERO", "VISIT", "GROUPE"),
    variable.name = "item",
    value.name = "value"
)

## TOTAL (HDRS + SCL90) -> long
df_total_long <- melt(
    df_total_wide,
    id.vars = c("NUMERO", "VISIT", "GROUPE"),
    variable.name = "item",
    value.name = "value"
)
```

\newpage
# Question 1 : Validation de l'échelle Hamilton

:::callout-note
**Consigne de la question 1** : Lorsque l’on utilise un instrument de mesure subjective dans une étude clinique, il est toujours bon de le (re)valider rapidement. Procédez ici à cette **vérification** sur l’échelle de dépression de Hamilton, aux temps J0 et J56.
:::

-   Vérification d'une échelle de mesure subjective = 1/ Que mesure l'instrument ? 2/ Que vaut la mesure ?

-   Premier temps : Évaluation préliminaire des réponses aux items, puis chercher une corrélation entre eux par une matrice de corrélation 2 à 2

-   Second temps : Analyse de la structure dimensionnelle = **que mesure l'instrument ?**

    -   Exploration de la structure par analyse en composante principale  : visualiser les relations entre les items

    -   Détermination du nombre de dimensions : diagramme des valeurs propres (*scree plot*) permet de déterminer le nombre de dimensions (composantes principales)

    -   Si structure dimensionnelle identifiée : **analyse factorielle** permet de déterminer quels items se regroupent dans chaque dimension

-   Troisième temps : Évaluation de la fiabilité interne = **que vaut la mesure ?**

    -   La consistance interne des items (évalue si les items sont cohérents entre eux) sera évaluée par le calcul de l'alpha de Cronbach

    -   Échelle de Hamilton = hétéro-évaluation donc on peut aussi évaluer la concordance inter-juges (ici entre les items) par le coefficient de corrélation intraclasse (CCI)

-   Quatrième temps : Évaluation de la validité = **l'instrument mesure-t-il ce qu'il est censé mesurer ?** (similaire à la question "que mesure l'instrument ?")

    -   Validité interne : déjà évaluée au cours du second temps (structure dimensionnelle)

    -   Validité externe : corrélation avec d'autres instruments de mesure (ici les dimensions de l'échelle SCL90)


## Valdidation.à J0

### Description 

Les réponses sont représentées : 

-   par des histogrammes pour chaque item de l'échelle de Hamilton à J0

-   par une matrice de corrélation 2 à 2 entre les items

NB : le code R utilise une fonction pour faciliter la création des histogrammes pour chaque item.

La fonction crée un histogramme pour chaque item listés dans un vecteur crée précédemment (`hdrs_items`).

```{r}
#| label: histo items J0
#| echo: false
#| eval: true
#| message: false
#| warning: false
#| fig-height: 3.5
#| fig-cap : "Histogrammes des scores des items de l'échelle de Hamilton à J0"

hdrs_J0 <- subset(hdrs_groupe, VISIT == "J0")

# Vraie palette Nord (package nord)
# On prend une palette qualitative (frost) et on l’étend à 5 couleurs
cols_nord <- nord::nord("frost", 5)

# Première série de graphiques (9 au maximum)
par(mfrow = c(3, 3), mar = c(2, 2, 2, 1))
items1 <- hdrs_items[1:min(9, length(hdrs_items))]
for (item in items1) {
    val <- na.omit(hdrs_J0[[item]])
    if (length(val) > 0) {
        m <- max(val)
        hist(val,
            main = item,
            xlab = "Score",
            col = cols_nord[1:(m + 1)],
            border = "white",
            breaks = seq(-0.5, m + 0.5, 1),
            xaxt = "n")
        axis(1, at = 0:m)
    } else {
        plot.new()
        title(main = paste(item, "(pas de données)"))
    }
    }
par(mfrow = c(1, 1))

# Deuxième série de graphiques (8 au maximum, de 10 à 17)
if (length(hdrs_items) > 9) {
    par(mfrow = c(3, 3), mar = c(2, 2, 2, 1))
    items2 <- hdrs_items[10:min(17, length(hdrs_items))]
    for (item in items2) {
        val <- na.omit(hdrs_J0[[item]])
        if (length(val) > 0) {
        m <- max(val)
        hist(val,
            main = item,
            xlab = "Score",
            col = cols_nord[1:(m + 1)],
            border = "white",
            breaks = seq(-0.5, m + 0.5, 1),
            xaxt = "n")
        axis(1, at = 0:m)
        } else {
        plot.new()
        title(main = paste(item, "(pas de données)"))
        }
    }
    par(mfrow = c(1, 1))
}
```

```{r}
#| label: matrice corrélation J0
#| echo: false
#| eval: true
#| message: false
#| results : hide
#| warning: false
#| fig-width: 8
#| fig-height: 5
#| fig-cap : "Matrice de corrélation entre les items de l'échelle de Hamilton à J0"
hdrs_J0_matrix <- hdrs_J0[, hdrs_items]
corr_matrix_J0 <- cor(hdrs_J0_matrix, use = "pairwise.complete.obs")

corrplot(corr_matrix_J0,
            method = "color",
            type = "upper",
            tl.col = "black",
            addCoef.col = "white",
            number.cex = 0.4,
            tl.cex = 0.8,
            tl.srt = 45,
            col = viridis::plasma(100)
            )
```

-   Il n'y a pas de données manquantes. 

-   Les histogrammes montrent que certains items ont une distribution asymétrique (ex : insomnie quelque soit le moment de la nuit, symptômes généraux, perte de poids...)

-   La matrice de corrélation des items 2 à 2 ne retrouve pas de coefficient de corrélation supérieure à 0,50 en valeur absolu, il n’existe pas de redondance entre les items de l’échelle Hamilton.

### Validité interne : structure dimensionnelle, analyse factorielle

```{r}
#| label: analyse factorielle J0
#| echo: false
#| eval: true
#| message: false
#| results : hide
#| warning: false
#| fig-width: 8
#| fig-height: 5
#| fig-cap : "Diagramme des valeurs propres (scree plot) des items de l'échelle de Hamilton à J0"
head(hdrs_J0[,c(hdrs_items)])
scree.plot(hdrs_J0[,c(hdrs_items)], simu=20, use = "P")
```

On estime à la louche 2 à 4 dimensions proéminentes.



### Validité externe

## Validation à J56

### Description

### Validité interne : structure dimensionnelle, analyse factorielle

### Validité externe

# Question 2 : Comparaison de la réponse au traitement entre deux groupes de patients
